/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.sootadapters.MethodDefinition;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

/**
 *
 * @author Mikosh
 */
@XmlRootElement
@XmlAccessorType (XmlAccessType.FIELD)
public class VulnerabilityMitigationItem {
    public static final String LOCAL = "LOCAL", FACTORY = "FACTORY", GLOBAL = "GLOBAL";
    private MethodDefinition methodDefinition;
    @XmlElement (name = "ParameterValue")
    private List<MethodParameterValue> parameterValues;
    @XmlElement (name = "MitigationType")
    private String type;
    @XmlElement (name = "SolutionDescription")
    private String solutionDescription;
    @XmlElement (name = "MitigationSpoiler")
    private List<MitigationSpoiler> mitigationSpoilers;

    public VulnerabilityMitigationItem() {}
    
    public VulnerabilityMitigationItem(MethodDefinition methodDefinition, List<MethodParameterValue> parameterValues, String type) {
        // first ensure the methoddefition and paramater values are compatible // 
        // make sure the parametervalue list is not null;
        parameterValues = (parameterValues == null) ? new ArrayList<MethodParameterValue>() : parameterValues;
        ensureParametersCompatibility(methodDefinition.getParameterList(), parameterValues);
        
        if (!type.equals(LOCAL) && !type.equals(FACTORY) && !type.equals(GLOBAL)) {
            throw new IllegalArgumentException("Invalid vulnerability mitigation type given");
        }
        
        this.methodDefinition = methodDefinition;
        this.parameterValues = parameterValues;
        this.type = type;
        
        this.mitigationSpoilers = new ArrayList<>();
    }
    
    private void ensureParametersCompatibility(List<MethodDefinition.MethodParameter> listMP, List<MethodParameterValue> listPV) {
        if (listMP.size() != listPV.size()) {
            throw new IllegalArgumentException("The number of parameter values should be equal to the number parameters "
                    + "expected by the method. Method expects " + listMP.size() + " but " + listPV.size() + " values were supplied.");            
        }
        for (int i=0; i< listMP.size(); ++i) {
            MethodDefinition.MethodParameter mp = listMP.get(i);
            MethodParameterValue pv = listPV.get(i);
            if (!mp.getType().equals(pv.getType())) {
                throw new RuntimeException("The method parameter type for argumemt " + (i+1) + " differs from the expected "
                        + "parameter value type (ie method parameter incompatible with value) See detail: MethodParameterType: " + 
                        mp.getType() + " != ParameterValueType: " + pv.getType());
            }
        }
        
        // may want to check valid values for primitive types
        
        // if method reaches here, it means there was no problem
    }

    public MethodDefinition getMethodDefinition() {
        return methodDefinition;
    }

    public List<MethodParameterValue> getParameterValues() {
        return parameterValues;
    }  

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
    
    public boolean isLocalMitigation() {
        return (type == VulnerabilityMitigationItem.LOCAL);
    }
    
    public boolean isFactoryMitigation() {
        return (type == VulnerabilityMitigationItem.FACTORY);
    }
    
    public boolean isGlobalMitigation() {
        return (type == VulnerabilityMitigationItem.GLOBAL);
    }

    public String getSolutionDescription() {
        return solutionDescription;
    }

    public void setSolutionDescription(String solutionDescription) {
        this.solutionDescription = solutionDescription;
    }

    public List<MitigationSpoiler> getMitigationSpoilers() {
        return mitigationSpoilers;
    }
    
    public boolean addMitigationSpoiler(MitigationSpoiler ms) {
        return mitigationSpoilers.add(ms);
    }
    
    
    
    
}
