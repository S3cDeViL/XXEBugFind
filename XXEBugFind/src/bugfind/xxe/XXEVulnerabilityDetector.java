/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.sootadapters.CallGraphObject;
import bugfind.sootadapters.CallSite;
import bugfind.sootadapters.MethodAnalysis;
import bugfind.sootadapters.MethodDefinition;
import bugfind.sootadapters.Variable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import soot.Body;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.jimple.Constant;
import soot.jimple.JimpleBody;
import soot.jimple.ParameterRef;
import soot.jimple.internal.ImmediateBox;
import soot.jimple.internal.JAssignStmt;
import soot.jimple.internal.JIdentityStmt;
import soot.jimple.internal.JInstanceFieldRef;
import soot.jimple.internal.JInvokeStmt;
import soot.jimple.internal.JimpleLocal;
import soot.jimple.internal.VariableBox;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.toolkits.graph.ClassicCompleteUnitGraph;
import soot.toolkits.graph.UnitGraph;

/**
 *
 * @author Mikosh
 */
public class XXEVulnerabilityDetector {
    protected CallGraphObject cgo;
    //protected List<VulnerabilityDefinitionItem> vulnerabilitesList;
    protected List<ActualVulnerabilityItem> xxeVulnerabilities;

    public XXEVulnerabilityDetector(CallGraphObject cgo) {
        this.cgo = cgo;
        
        
    }
    
    public List<ActualVulnerabilityItem> checkForXXEVulnerabilities() {
        xxeVulnerabilities = new ArrayList<>();
        CallGraph cGraph = Scene.v().getCallGraph();
        MethodAnalysis mAnalysis = new MethodAnalysis(cgo, cGraph);
////        if (vulnerabilitesList != null) {
////            vulnerabilitesList.clear();            
////        }
        SootMethod sm = Scene.v().getSootClass("myxmltest.MyXMLTest").getMethodByName("sampleMeth");
        Body bdd = sm.getActiveBody();
        JimpleBody jb = (JimpleBody) bdd; JIdentityStmt jis = (JIdentityStmt) jb.getUnits().getFirst();
        jis.getLeftOp();
        int jj=0;
        
        List<VulnerabilityDefinitionItem> vulDefList = VulnerableXMLMethodDefinitions.getVulnerableMethodDefinitionList();       
//        this.vulnerabilitesList = new ArrayList<>(vulDefList.size());
//        this.vulnerabilitesList.
//        Collections.copy(this.vulnerabilitesList, vulDefList);
//        
        for (VulnerabilityDefinitionItem vdi : vulDefList) {
//            if (!vdi.getMethodDefinition().getClassName().toLowerCase().contains("saxpars")) {
//                continue; // skip document builder for now;
//            }
            
            // if the class exists then it means the class is being used
            if (classExists(vdi.getMethodDefinition().getClassName())) {SootClass sc;// = Scene.v().gets
                //this.cgo.getMethodCallEdgesOutOfMethod(Scene.v().getCallGraph(), null)
                List<CallSite> listCS = this.cgo.getCallSites(cGraph, 
                        MethodDefinition.getSootMethod(Scene.v().getSootClass(vdi.getMethodDefinition().getClassName()), vdi.getMethodDefinition()));               
                List<VulnerabilityMitigationItem> listMitigationItems =  vdi.getMitigationList();
                
                if (listCS.isEmpty()) {// if there are no uses of the parser methods then continue
                    continue;
                }
                
                ActualVulnerabilityItem avi = new ActualVulnerabilityItem(vdi);
                avi.addVulnerabilityOccurrences(listCS);
                avi.setReason(vdi.getMitigationList().get(0).getSolutionDescription());
                this.xxeVulnerabilities.add(avi);
                                
                // for each call site, try to check if the mitigation attempts to solve the problem
                for (CallSite cs: listCS) {
                    //System.out.println(" possible application xxe vulnerability detected:\n" + cs);
                    
                    boolean isMitigated = false;
                    
                    SootMethod parentMethod = cs.getEdge().src();
                    SootMethod vulMethod = cs.getEdge().tgt();

                    // try to check if any of the mitigation attempts solves the problem 
                    // also check that the others are okay // later edit
                    // for now only immediate local mitigations are considered, static will be considered later
                    for (VulnerabilityMitigationItem vmi : listMitigationItems) {
                        if  (vmi.isGlobalMitigation() ) {
                            continue; // skip global for now;
                        }
                        
                        
                        UnitGraph uv = new ClassicCompleteUnitGraph(cs.getEdge().src().getActiveBody());
                        List<Unit> l = uv.getPredsOf(cs.getEdge().srcStmt());
                        
                        //cs.getEdge().srcStmt().getBoxesPointingToThis();
                        //DocumentBuilderFactory fi;fi.set
                        //this.cgo.getCallSites(cGraph, vulMethod);
                        //Scene.v().getCallGraph().edgesInto(Scene.v().getSootClass("javax.xml.parsers.DocumentBuilderFactory").getMethodByName("setFeature")).
                        //Scene.v().getSootClass("javax.xml.parsers.DocumentBuilderFactory").getMethodByName("setFeature");
                       
                        SootMethod solMeth = MethodDefinition.getSootMethod(Scene.v().getSootClass(vmi.getMethodDefinition().getClassName()),
                                vmi.getMethodDefinition()); 
                        List<CallSite> listSolnCS = this.cgo.getCallSitesInMethod(cGraph, solMeth, parentMethod);                       
                        Collections.sort(listSolnCS);// sort according to line number occurrence (it is implemeneted in CallSite's comparable interface method)
                       
                        // first check if the setting should be applied on the xml parser itself or the the parser factory
                        if (!solMeth.getDeclaringClass().getName().equals(vdi.getMethodDefinition().getClassName())) {
                            // if the mitigation is not be applied on same object, ie to be on factory
                            // ensure that the factory is actually used to build the parser
                            boolean isAssigned = mAnalysis.isAssignedTo(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName());
                            if (!isAssigned) {
                                throw new RuntimeException("no relationship between vulnerable method and mitigation setting");
                            }
                        }
                      
                        // continue (ie skip loop) if solMethod (mitigation attempt) isnt called in parent method
                        if (!mAnalysis.isCalledInMethod(parentMethod, solMeth)) {
                            continue;
                        }
                        
                        int order = mAnalysis.compare(parentMethod, solMeth, vulMethod);
                        // first check if fix is applied before xml parse method 
                        // next check if the correct settings have been applied
                        if (order == MethodAnalysis.CALLED_BEFORE) {// 
                            listSolnCS = mAnalysis.getAllCallsBefore(parentMethod, solMeth, vulMethod);
                            // now filter to get the last mitigation call that was applied
                            Variable v = mAnalysis.getAssigenerVariable(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName());
                            // filter by variable
                            listSolnCS = mAnalysis.filterByVariable(listCS, v);
                            
                            for (CallSite aCs : listSolnCS) {
                                int result = mAnalysis.compareArguments(aCs, vmi.getParameterValues());
                            
                            if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
                                //if (mAnalysis.isInvokedOnSameVariable(null, null))
                                avi.getOccurrencesList().remove(cs);
                                if (avi.getOccurrencesList().isEmpty()) {
                                    xxeVulnerabilities.remove(avi);
                                }
                                break;
                            }
                            }
//                            int result = mAnalysis.compareArguments(listSolnCS.get(0), vmi.getParameterValues());
//                            
//                            if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
//                                //if (mAnalysis.isInvokedOnSameVariable(null, null))
//                                avi.getOccurrencesList().remove(cs);
//                                if (avi.getOccurrencesList().isEmpty()) {
//                                    xxeVulnerabilities.remove(avi);
//                                }
//                                break;
//                            }
                        }

                    }

                    

                    
                }
            }
        }        
        
        return new ArrayList<>(xxeVulnerabilities);
        
    }
    
    protected boolean classExists(String className) {
        return Scene.v().containsClass(className);
    }
    
    
    private void doTest(CallSite cs) {
        ImmediateBox b; JimpleLocal jl; JInvokeStmt h; JAssignStmt j; Constant c; JInstanceFieldRef g; VariableBox vb; //Value v = new   ;
        ArrayList al = new ArrayList<Unit>(cs.getEdge().src().getActiveBody().getUnits());//.getLocals();
        JInvokeStmt jl2 = (JInvokeStmt) al.get(2); Value v = new JimpleLocal(null, null);
        //jl2.getInvokeExpr().;cs.getEdge().srcStmt().getInvokeExpr().getArgs();
        //((JAssignStmt)al.get(1)).getInvokeExpr()
        //((JAssignStmt)al.get(8)).getInvokeExpr()//getDefBoxes().get(0).getValue();         
        //((VariableBox)((JAssignStmt)al.get(8)).getDefBoxes().get(0)).getValue(); 
        ((JInvokeStmt)al.get(2)).getInvokeExpr().getArgs().get(0).getType();
        new ArrayList<SootField>(cs.getEdge().src().getDeclaringClass().getFields());//.getFirst().;
    }
}
