/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package bugfind.xxe;

import bugfind.main.OptionsParser;
import bugfind.sootadapters.CallGraphObject;
import bugfind.sootadapters.CallSite;
import bugfind.sootadapters.MethodAnalysis;
import bugfind.sootadapters.MethodDefinition;
import bugfind.sootadapters.Variable;
import bugfind.utils.misc.XMLUtils;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.bind.JAXBException;
import javax.xml.stream.XMLStreamException;
import soot.Local;
import soot.Scene;
import soot.SootClass;
import soot.SootField;
import soot.SootMethod;
import soot.Unit;
import soot.Value;
import soot.jimple.Constant;
import soot.jimple.internal.ImmediateBox;
import soot.jimple.internal.JAssignStmt;
import soot.jimple.internal.JInstanceFieldRef;
import soot.jimple.internal.JInvokeStmt;
import soot.jimple.internal.JNewExpr;
import soot.jimple.internal.JimpleLocal;
import soot.jimple.internal.VariableBox;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.TransitiveTargets;
import soot.jimple.toolkits.infoflow.InfoFlowAnalysis;
import soot.toolkits.graph.ExceptionalUnitGraph;
import soot.toolkits.graph.UnitGraph;
import soot.toolkits.scalar.ArraySparseSet;
import soot.toolkits.scalar.CombinedAnalysis;
import soot.toolkits.scalar.CombinedDUAnalysis;
import soot.toolkits.scalar.FlowSet;
import soot.toolkits.scalar.ForwardFlowAnalysis;
import soot.toolkits.scalar.SimpleLiveLocals;
import soot.toolkits.scalar.SimpleLocalUses;
import soottest.GuaranteedDefs;

/**
 *
 * @author Mikosh
 */
public class XXEVulnerabilityDetector {
    protected CallGraphObject cgo;
    //protected List<VulnerabilityDefinitionItem> vulnerabilitesList;
    protected List<ActualVulnerabilityItem> xxeVulnerabilities;

    public XXEVulnerabilityDetector(CallGraphObject cgo) {
        this.cgo = cgo;        
    }
    
    public List<ActualVulnerabilityItem> findVulnerabilities() {
        if (true) {doTest(cgo); return null;}
        
        xxeVulnerabilities = new ArrayList<>();
        CallGraph cGraph = Scene.v().getCallGraph();
        MethodAnalysis mAnalysis = new MethodAnalysis(cgo, cGraph);
////        if (vulnerabilitesList != null) {
////            vulnerabilitesList.clear();            
////        }

        
        Map<String, String> bugFindParametersMap = cgo.getBugFindParametersMap();
        String custRulesetLoc = bugFindParametersMap.get(OptionsParser.RULESET_OPT);
        
        List<VulnerabilityDefinitionItem> vulDefList = null;
        
        if (custRulesetLoc != null) {
            try {
                VulnerabilityDefinitionItems vdItems = XMLUtils.convertToPojo(new File(custRulesetLoc), VulnerabilityDefinitionItems.class);
                vulDefList = vdItems.getVulnerabilityDefinitionItems();
            } catch (JAXBException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            } catch (XMLStreamException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            } catch (FileNotFoundException ex) {
                Logger.getLogger(XXEVulnerabilityDetector.class.getName()).log(Level.SEVERE, null, ex);
                System.exit(0);
            }
        }
        else {
            vulDefList = VulnerableXMLMethodDefinitions.getVulnerableMethodDefinitionList();
        }
        
        
        
        for (VulnerabilityDefinitionItem vdi : vulDefList) {            
            // if the class exists then it means the class is being used
            if (classExists(vdi.getMethodDefinition().getClassName())) {SootClass sc;// = Scene.v().gets
                //this.cgo.getMethodCallEdgesOutOfMethod(Scene.v().getCallGraph(), null)
                List<CallSite> listCS = this.cgo.getCallSites(cGraph, 
                        MethodDefinition.getSootMethod(Scene.v().getSootClass(vdi.getMethodDefinition().getClassName()), vdi.getMethodDefinition()));               
                List<VulnerabilityMitigationItem> listMitigationItems =  vdi.getMitigationList();
                
                if (listCS.isEmpty()) {// if there are no uses of the parser methods then continue
                    continue;
                }
                
                ActualVulnerabilityItem avi = new ActualVulnerabilityItem(vdi);
                avi.addVulnerabilityOccurrences(listCS);
                avi.setReason(vdi.getMitigationList().get(0).getSolutionDescription());
                this.xxeVulnerabilities.add(avi);
                                
                // for each call site, try to check if the mitigation attempts to solve the problem
                for (CallSite cs: listCS) {
                    //System.out.println(" possible application xxe vulnerability detected:\n" + cs);
                    
                    boolean isMitigated = false;
                    
                    SootMethod parentMethod = cs.getEdge().src();
                    SootMethod vulMethod = cs.getEdge().tgt();

                    // try to check if any of the mitigation attempts solves the problem 
                    // also check that the others are okay // later edit
                    // for now only immediate local mitigations are considered, static will be considered later
                    for (VulnerabilityMitigationItem vmi : listMitigationItems) {
                        if  (vmi.isGlobalMitigation() ) {
                            continue; // skip global for now;
                        }
                       
                        SootMethod solMeth = MethodDefinition.getSootMethod(Scene.v().getSootClass(vmi.getMethodDefinition().getClassName()),
                                vmi.getMethodDefinition()); 
                        List<CallSite> listSolnCS = this.cgo.getCallSitesInMethod(cGraph, solMeth, parentMethod);                       
                        Collections.sort(listSolnCS);// sort according to line number occurrence (it is implemeneted in CallSite's comparable interface method)
                       
                        // first check if the setting should be applied on the xml parser itself or the the parser factory
                        if (!solMeth.getDeclaringClass().getName().equals(vdi.getMethodDefinition().getClassName())) {
                            // if the mitigation is not be applied on same object, ie to be on factory
                            // ensure that the factory is actually used to build the parser
                            boolean isAssigned = mAnalysis.isAssignedTo(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName());
                            if (!isAssigned) {
                                throw new RuntimeException("no relationship between vulnerable method and mitigation setting");
                            }
                        }
                      
                        // continue (ie skip loop) if solMethod (mitigation attempt) isnt called in parent method
                        if (!mAnalysis.isCalledInMethod(parentMethod, solMeth)) {
                            continue;
                        }
                        
                        int order = mAnalysis.compare(parentMethod, solMeth, vulMethod);
                        // first check if fix is applied before xml parse method 
                        // next check if the correct settings have been applied
                        if (order == MethodAnalysis.CALLED_BEFORE) {// 
                            listSolnCS = mAnalysis.getAllCallsBefore(parentMethod, solMeth, vulMethod);
                            // now filter to get the last mitigation call that was applied
                            Variable v = (!solMeth.getDeclaringClass().getName().equals(vdi.getMethodDefinition().getClassName())) 
                                    ?                                    
                                    mAnalysis.getAssignerVariable(parentMethod, solMeth.getDeclaringClass().getName(), 
                                    vdi.getMethodDefinition().getClassName())
                                    :
                                    mAnalysis.getInvokedVariable(cs.getEdge().srcStmt());
                            // filter by variable.(ie the variable that has a direct connection to the parser variable)
                            listSolnCS = mAnalysis.filterByVariable(listSolnCS, v);
                            
                            
                            Iterator<CallSite> iteCs = listSolnCS.iterator();
                            
                            boolean mitigationSet = false, mitigationCanceled = false, possibleMitigationIsCanceled = false;
                            while (iteCs.hasNext()) {
                                CallSite aCs = iteCs.next();
                                
                                int result = mAnalysis.compareArguments(aCs, vmi.getParameterValues());
                            
                                if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
                                    mitigationSet = true; mitigationCanceled = false; possibleMitigationIsCanceled = false;
                                    //if (mAnalysis.isInvokedOnSameVariable(null, null))                                    
                                }
                                
                                if (mitigationSet) {
                                    // if there are more method calls of the mitigation, check that the rest are properly set
                                    // otherwise they may infact reverse the mitigation
                                    List<MitigationSpoiler> mitigationSpoilers = vmi.getMitigationSpoilers();                                    
                                    if (!mitigationSpoilers.isEmpty()) {
                                        while (iteCs.hasNext()) {
                                            CallSite nextCs = iteCs.next();
                                            for (MitigationSpoiler ms : mitigationSpoilers) {
                                                int tempResult = mAnalysis.compareArguments(nextCs, ms.getParameterValues());
                                                
                                                if (tempResult == MethodAnalysis.SAME_ARGUMENT_VALUES) {// ie mitigation spoiled/canceled
                                                    // we can only conclude that the mitigation is truely canceled if there is no any other callsie after this one
                                                    if (iteCs.hasNext()) {                                                        
                                                        mitigationCanceled = false;
                                                        possibleMitigationIsCanceled = true;
                                                    } else {
                                                        mitigationSet = false;
                                                        mitigationCanceled = true;
                                                        possibleMitigationIsCanceled = false;
                                                    }
                                                    break;
                                                }                                                
                                            }
                                            
                                            if (mitigationCanceled || possibleMitigationIsCanceled) {
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (mitigationCanceled) {
                                    break;
                                }

                                if (!mitigationCanceled && !possibleMitigationIsCanceled && mitigationSet) {
                                    avi.getOccurrencesList().remove(cs);
                                    if (avi.getOccurrencesList().isEmpty()) {
                                        xxeVulnerabilities.remove(avi);
                                    }
                                    break;
                                }

                                // this below is implied.
                                //if (possibleMitigationIsCanceled) {
                                //    continue;
                                //}
                            }                            
                            
//-------------------------
//                            int result = mAnalysis.compareArguments(listSolnCS.get(0), vmi.getParameterValues());
//                            
//                            if (result == MethodAnalysis.SAME_ARGUMENT_VALUES) {
//                                //if (mAnalysis.isInvokedOnSameVariable(null, null))
//                                avi.getOccurrencesList().remove(cs);
//                                if (avi.getOccurrencesList().isEmpty()) {
//                                    xxeVulnerabilities.remove(avi);
//                                }
//                                break;
//                            }
                        }

                    }

                    

                    
                }
            }
        }        
        
        return new ArrayList<>(xxeVulnerabilities);
        
    }
    
    protected boolean classExists(String className) {
        return Scene.v().containsClass(className);
    }
    
    
    public static void doTest(CallGraphObject cgo) {
        List<VulnerabilityDefinitionItem> vulDefList = VulnerableXMLMethodDefinitions.getVulnerableMethodDefinitionList();       
        
        XXEVulnerabilityDetector xvd = new XXEVulnerabilityDetector(cgo);
        CallGraph cGraph = Scene.v().getCallGraph();
        for (VulnerabilityDefinitionItem vdi : vulDefList) { //cgo.getMethodCallEdgesOutOfMethod(cGraph, Scene.v().getSootClass("a.PrettyPrinter").getMethodByName("main"))//Scene.v().getSootClass("org.jdom2.input.SAXBuilder").getMethods();//xvd.classExists("org.jdom2.input.SAXBuilderd");
            List<CallSite> listCS = cgo.getCallSites(cGraph, 
                        MethodDefinition.getSootMethod(Scene.v().getSootClass(vdi.getMethodDefinition().getClassName()), vdi.getMethodDefinition()));               
                List<VulnerabilityMitigationItem> listMitigationItems =  vdi.getMitigationList();
                
                if (listCS.isEmpty()) {// if there are no uses of the parser methods then continue
                    continue;
                }
                
                ActualVulnerabilityItem avi = new ActualVulnerabilityItem(vdi);
                avi.addVulnerabilityOccurrences(listCS);
                avi.setReason(vdi.getMitigationList().get(0).getSolutionDescription());
            
                                
                // for each call site, try to check if the mitigation attempts to solve the problem
                for (CallSite cs: listCS) {
                    doTest(cs);
                }
            
        }
        
    }
    
    public static void doTest(CallSite cs) {
        List lst = new CallGraphObject(null).getMethodCallEdgesOutOfMethod(Scene.v().getCallGraph(), cs.getSourceMethod());
        
        UnitGraph uv = new ExceptionalUnitGraph(cs.getEdge().src().getActiveBody());//ClassicCompleteUnitGraph(cs.getEdge().src().getActiveBody());
        List<Unit> l = uv.getPredsOf(cs.getEdge().srcStmt()); //cs.getEdge().src().getActiveBody().get; ValueBox
        //FlowUniverse fu = new 
        //InfoFlowAnalysis ifa = new InfoFlowAnalysis(false, false);
        uv.getSuccsOf(cs.getEdge().srcStmt());
        InfoFlowAnalysis ifa = new InfoFlowAnalysis(false, false);

        CallGraph cg = Scene.v().getCallGraph();
        // Find every application  class
//        List heads = new LinkedList();
//        Iterator getClassesIt
//                = Scene.v().getApplicationClasses().iterator();
//        while (getClassesIt.hasNext()) {
//            SootClass appClass = (SootClass) getClassesIt.next();
//            Iterator methodsIt = appClass.getMethods().iterator();
//            while (methodsIt.hasNext()) {
//                SootMethod method = (SootMethod) methodsIt.next();
//                DirectedGraph flowSummary
//                        = ifa.getMethodInfoFlowSummary(method);
//
//                InfoFlowAnalysis.printInfoFlowSummary(flowSummary);
//            }
//        }
//        
//        
//        //SmartMethodInfoFlowAnalysis smifa = new SmartMethodInfoFlowAnalysis(uv, ifa);
//        SmartMethodInfoFlowAnalysis smifa2 = ifa.getMethodInfoFlowAnalysis(cs.getEdge().src());
//        smifa2.generateInfoFlowSummary();
//
//        //HashMutableDirectedGraph hmdg2 = smifa.getMethodAbbreviatedInfoFlowGraph();
//        HashMutableDirectedGraph hmdg = smifa2.getMethodInfoFlowSummary();
//        //hmdg.getPredsOf(l)
////InfoFlowAnalysis.getMethodInfoFlowAnalysis(method);
////smifa.getMethodInfoFlowSummary(); // same as above
////smifa.getMethodAbbreviatedInfoFlowGraph();
//        SimpleMethodInfoFlowAnalysis smia = new SimpleMethodInfoFlowAnalysis(uv, ifa, true);
        FlowSet fs = new ArraySparseSet();ForwardFlowAnalysis h;
        ArraySparseSet ass; 
        GuaranteedDefs gDefs = new GuaranteedDefs(uv);;
        cs.getEdge().src().getActiveBody();uv.getSuccsOf(cs.getEdge().srcStmt());
        int val = (l.size() < 6) ? l.size()-1 : 5;
        List gdefs = gDefs.getGuaranteedDefs(l.get(val));
        
        SimpleLiveLocals sll = new SimpleLiveLocals(uv);
        sll.getLiveLocalsBefore(l.get(val));
        sll.getLiveLocalsAfter(l.get(val));
        TransitiveTargets f = new TransitiveTargets(cg); 
        f.iterator(cs.getSourceMethod());
        CombinedAnalysis ca = CombinedDUAnalysis.v(uv);
        List<Unit> units = new ArrayList<>(cs.getEdge().src().getActiveBody().getUnits());
        List<Local> ll = new ArrayList<>(cs.getEdge().src().getActiveBody().getLocals());
      //(((JAssignStmt)units.get(8)).getRightOp()   
        ca.getLiveLocalsAfter(units.get(6));
        ca.getLiveLocalsBefore(units.get(6)); //((JInvokeStmt)units.get(10)).getInvokeExpr()
        ca.getDefsOfAt(ll.get(11), units.get(10));JNewExpr jne;
        uv.getSuccsOf(units.get(9));SootClass sc;
        //((JAssignStmt)ca.getDefsOfAt(ll.get(11), units.get(11)).get(0)).getRightOp()//  ((JAssignStmt)ca.getDefsOfAt(ll.get(14), units.get(21)).get(0)).getRightOp()
        ca.getDefsOfAt(ll.get(14), ca.getDefsOfAt(ll.get(14), units.get(21)).get(0));
        
        SimpleLocalUses slu = new SimpleLocalUses(cs.getEdge().src().getActiveBody(), ca);
        slu.getUsesOf(units.get(1));
        
        int i=7;
                        //cs.getEdge().srcStmt().getBoxesPointingToThis();
                        //DocumentBuilderFactory fi;fi.set
                        //this.cgo.getCallSites(cGraph, vulMethod);
                        //Scene.v().getCallGraph().edgesInto(Scene.v().getSootClass("javax.xml.parsers.DocumentBuilderFactory").getMethodByName("setFeature")).
                        //Scene.v().getSootClass("javax.xml.parsers.DocumentBuilderFactory").getMethodByName("setFeature");
        
//        SootMethod sm = Scene.v().getSootClass("myxmltest.MyXMLTest").getMethodByName("sampleMeth");
//        Body bdd = sm.getActiveBody();
//        JimpleBody jb = (JimpleBody) bdd; JIdentityStmt jis = (JIdentityStmt) jb.getUnits().getFirst();
//        jis.getLeftOp();
//        int jj=0;
        
        ImmediateBox b; JimpleLocal jl; JInvokeStmt hs; JAssignStmt j; Constant c; JInstanceFieldRef g; VariableBox vb; //Value v = new   ;
        ArrayList al = new ArrayList<Unit>(cs.getEdge().src().getActiveBody().getUnits());//.getLocals();
        JInvokeStmt jl2 = (JInvokeStmt) al.get(2); Value v = new JimpleLocal(null, null);
        //jl2.getInvokeExpr().;cs.getEdge().srcStmt().getInvokeExpr().getArgs();
        //((JAssignStmt)al.get(1)).getInvokeExpr()
        //((JAssignStmt)al.get(8)).getInvokeExpr()//getDefBoxes().get(0).getValue();         
        //((VariableBox)((JAssignStmt)al.get(8)).getDefBoxes().get(0)).getValue(); 
        //((JInvokeStmt)al.get(2)).getInvokeExpr().getArgs().get(0).getType();
        new ArrayList<SootField>(cs.getEdge().src().getDeclaringClass().getFields());//.getFirst().;
    }
    
    
}
